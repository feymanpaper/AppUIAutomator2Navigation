## 环境配置
配置uiautomator2环境:https://github.com/openatx/uiautomator2

配置frida环境: https://github.com/frida/frida

配置tesseract环境,同时需要配置中文语言包:  https://github.com/tesseract-ocr/tesseract

配置yolov5环境。https://github.com/ultralytics/yolov5

将系统编码方式改成utf-8而非gbk

## 运行
在apk_pkgName.txt中更改要测试的包名及应用名,格式为包名 | 应用名。支持批量分析。注意|的左右两边都需要有一个空格。
在config.ini配置文件中可以设置遍历层数等运行参数
还有部分高级配置，可在Config.py中修改。如需修改，请确认只修改所标记部分。
运行`python run_config.py`

## 遍历过程
### 点击过程
对于一个界面，会遍历当前界面的所有可点击组件进行依次点击，
由于点击之后可能会触达新的界面，因此需要在点击之前维护当前界面的上下文，
如当前界面的界面信息(文本, 位置), 当前界面已经点击了哪些组件...

每到达一个界面, 我们会将当前界面的界面信息(文本, 组件位置等)和Memory(存储之前遍历过的界面信息)
进行相似度比较, 如果相似度大于阈值, 认为当前界面是一个已经存在的界面(ExistScreen), 否则认为是一个新的界面(NewScreen)。
取出当前界面的上下文后，从上次点击未完成的组件开始继续点击。如果当前界面已经点击完成, 就触发
press back回退, 到上一层界面进行点击, 重复上述流程。

一个界面点击完成的定义: 该界面所有可点击组件均点击完成
一个可点击组件点击完成的定义: 该组件不会产生页面跳转 或 该组件对应的下一跳界面点击完成

### 状态检测
定义了以下状态:
| 状态     | 描述 |对应处理|  
| ----------- | ----------- | ----------- |  
| STATE_ExitApp      | 当前跳出了测试App       |press back回退到测试App|  
| STATE_InputMethod   | 当前遇到输入法        |press back退出输入法|  
| STATE_ExistScreen   | 当前界面已经存在        |取出当前界面上下文并继续点击|  
| STATE_FinishScreen   | 当前界面点击完成        |press back回退到上一层界面|  
| STATE_NewScreen   | 当前界面为新触达界面        |为新界面分配上下文并且加入到App界面跳转图, 开始点击|  
| STATE_PermissonScree   | 当前界面为系统权限框        |随机点击策略|  
| STATE_HomeScreenRestart | 当前界面被卡住 | 重启App|  
| STATE_Back | 当前界面为ErrorScreen, ExceedDepth | press back退出当前界面|

## 特性

### 隐私导向
优先遍历隐私界面: 每个界面维护一个可点击组件的List, 在加入可点击组件的过程中, 如果该可点击组件的文本  
与隐私相关(keyword匹配), 则从List头部插入该组件, 否则从尾部append, 保证隐私相关组件优先点击. 

获取隐私政策url: 在遍历界面的过程中如果发现隐私政策相关文本(先通过frida hook改掉截屏参数, 使得能够  
正常截屏, 然后OCR截屏文本查看是否存在隐私政策文本), 会通过frida hook相关函数拿到隐私政策的url并记录  
方便后续爬取.

### 层次遍历
由于商业化的App非常复杂, 可能存在数百个Activity和数万个界面, 而用户未必关心非常深层的界面. 因此支持  
用户配置遍历的层数MaxDepth, 工具在遍历时会从层数1开始遍历, 只遍历第1层的界面, 当检查到第一层的界面遍历  
完成后会将层数增加到2.... 不断遍历直到遍历完配置的层数的界面. 

### 处理Activity内Fragment, Menu, Drawer
Activity内部存在Fragment, Menu, Drawer等组件. Activity是表现为栈, 然而一个Activity内  
可能存在多个Fragment, 每个Fragment是不同的界面, 而Fragment并不一定表现为栈(取决于开发者的设计).   
因此用DFS(栈)难以模拟界面的行为. 

思路: 我们采用了有限状态机模型(FSM)来模拟界面的行为. 并结合重启App和检测环路的策略来保证能覆  
盖全Fragment, Menu, Dialog, Drawer的场景.

### 处理弹框(Dialog, Popup Window)
App经常会弹出弹框, 如果不点掉弹框会一直存在, 阻碍遍历测试的正常运行, 甚至会导致测试卡住. 而且弹框不仅会  
发生在点击组件的过程中, 也会发生在press back回退的过程中. 

思路: 采用两个Yolov5目标检测模型, 首先模型1 检测当前界面是否为弹框界面, 如果当前界面为弹框界面, 则  
使用模型2 检测出当前界面的弹框点击选项位置信息, 进行点击.  

### 界面去重
由于App的同一个界面的元素是会频繁发生少量变化的, 因此需要对界面去重, 将发生少量变化的界面认为是相同的界面，
而不是认为是全新的界面。

思路: 每到达一个界面, 会将当前界面的界面uid(界面可点击组件的文本, 位置拼接成字符串)和Memory(存储之前遍历  
过的所有界面uid)进行相似度比较, 如果相似度大于某个阈值(90%), 认为当前界面是一个已经存在的界面, 没必要认为  
是一个新界面, 则取出该界面的上下文继续进行点击。  

当界面元素发生变化时, 往往是增加/减少部分组件或者部分组件的文本/位置信息发生变更, 因此采用的相似度比较算
法为最长公共子序列(LCS)算法, 而不需要关注字符串具体的语义信息(没有采用NLP相关的算法).

### 提高覆盖率
若对每个组件只允许点击一次，会造成许多界面无法遍历到。
因此程序会记录每个可点击组件触达的下一个界面nextScreen。若nextScreen没点击完成，
将继续点击该组件跳转到nextScreen去继续点击。同时会检测回边/环的情况, 避免进入到死循环。

### 容错机制
当press back回退到上一层界面, 此时可能会遇到弹框或回退无效等卡住的情况, 会影响工具继续遍历.
这种情况下程序将触发:  

1.随机点机制, 从可能产生界面跳转的组件中随机选择一个组件点击.

2.若还是不能回退, 则重启测试app, 并且记录卡住的界面和触达该界面所点击的组件,
以避免重启之后再次点击.

### 绘制App界面跳转图
记录App遍历过程中的界面跳转图以及界面截图, 遍历结束时输出由界面截图和跳转箭头组成的界面跳转图.




